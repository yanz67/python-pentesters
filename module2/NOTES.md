## Process Creation

### Forking
- Forking (cloning) creates an identical process as the parent
    - `os.fork()`
    - after calling `os.fork()` the same code is executed simultaneously in both processes 
- the thread of execution is duplicated exactly at the point of call to fork()
    - returns 0 in the child
    - returns pid of child in the parent
- PID is different for parent / child
### using fork()
- Dedicated child to a task give by the parent
- parent and child can communicate if required using IPC
- parent / child binary remains the same

### Spawning New Processes
- `os.exec*` functions
    - different binary
    - `os.excl`
    - `os.excle`
- Overlays parent process with the child

### Python Threads
CPython implementation detail: Due to Global Interpreter Lock, in CPython only one 
thread can execute Python code at once. If you want your application to make better 
of use the computational resources of multi-core machines, you are advised to use
multiprocessing.  However, threading is still an appropriate model if you want to run multiple
I/O-bound tasks simultaneously.

- Simple threads using the thread module
- More complicated ones using the threading module

### Threading and Queues
The queue module implements multi-producer, multi-consumer queues. It is especially useful in threaded programming when 
information must be exchanged safely between multiple threads. The Queue class in this module implements all the required locking semantics.
The Python threading module uses threads instead of processes. 

### Multi-threading and Multi-processing
Threads uniquely run in the same unique memory heap. 
Whereas Processes run in separate memory heaps

### Signals
 - Allows handling of Asynchronous events
 - SIGKILL is what gets sent when you use `kill -9`
 
### Subprocess
 - Sub process helps you invokes other processes and interact with them
```python
import subprocess
subprocess.call(['ls', '-ltr'])
output = subprocess.check_output(['ls', '-ltr'])  # returns bytes string of the output
```
