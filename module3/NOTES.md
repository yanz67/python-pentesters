## Network Programming

### Socket programming 
    - TCP and UDP Sockets
        - Regular Servers and Clients 
    - Raw Sockets
        - Sniffing and Injection
### Simple TCP Server and Client
- Socket is a network endpoint for communication between two more more entities
- Using socket module in Python
    - Create TCP socket which will be listening on a specific port
        - `tcpSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)`
            - `socket.AF_INET` Address Family which is for internet application usually AF_INET
                - A pair (host, port) is used for the AF_INET address family, where host is a string representing either 
                a hostname in Internet domain notation like 'daring.cwi.nl' or an IPv4 address like '100.50.200.5', 
                and port is an integer.
            - `socket.SOCK_STREAM` Socket type (SOCK_STREAM for TCP)
        - Bind a socket to a port which also includes binding to a specific interface
            - `tcpSocket.bind(("0.0.0.0", 8000))`
                - bind method accepts a tuple with interface IP address and port
        - Call `listen` to start accepting clients
            - `tcpsocket.listen(2)`
        - Call `accept` method to start waiting for connections
            - `accept` returns a tuple when client connects `(client, (ip, port))`
                - with each client connects accept will return a different client socket with IP and Port
                - accept is blocking call and will wait until client connects
        - send data to the client using client object
            - `client.data('hello world)`
        - receive data from client
            - `data = client.recv(2048)` providing the size of the buffer
    - Reusing port and ip address immediately after a program exists    
        - To insure fast reuse you can set an option on the socket for address reuse
            - `tcpSocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)`
    - Create TCP client which connects to a server
        - Create a socket
        - call `connect` to connect to the server `tcpSocket.connect((IP, PORT))`

### SocketServer
- Framework in Python to create TCP and UDP servers
- Does all the basic steps in the background
- Comes in handy of you want to create a server to lure a client and analyzer its behaviour
- Module Usage
    - Create a subclass of `BaseRequestHandler`
    - Override `hadle()` to process request
    - Call `handle_request()` or `serve_forever()` to process clients
    - For TCP Servers
     - `self.request` is the client socket
     - `self.client_address` is the client details
- Creating a web application server
    - Listen on port 80 (HTTP) / 443 (HTTPS) by default on incoming connections.
    - Wait for client requests (GET, POST, HEAD ...)
    - Process requests
        - Serve files
        - Execute scripts on the server side and return response
    - `SimpleHTTPServer class`
        - Implement `do_GET()`
        - can be used to server exploit code to a client
        - can be used to penteration test client side code
    
### Packet Sniffing with Raw Sockets
- Raw sockets provide a way to bypass the whole network stack traversal of a packet and deliver it directly 
to an application. No data is stripped and the application can analyze the full packet
- `PF_PACKET` interface 
    - It is a software interface to send/receive packets at layer 2 of the OSI (i.e. device driver)
    - All packets received will be complete with all headers and data
    - All packets sent will be transmitted without modification by the kernel to the medium
    - Supports filtering using Berkley Packet filter
- Creating Raw Sockets
    - use the socket module
    - read packets
    - interpret and analyze them
    - can send out responses as well
- Understanding Packet Headers
    - Whole stack works with encapsulation (Ethernet is encapsulate IP encapsulate TCP encapsulates Application)
    - Packet in a sequence of encapsulation
    - First 14 bytes is the ethernet header
    - Next 20 or so bytes weather you have options or not
    - Order of parsing packets will be the same
    - The data is sent over the network converted to Network Byte Order (Big-Endian format)
    - First character indicates byte ordering
    - On intel machines data is stored in Little-Endian format.
    - Sending packets in Big-Endian format but data in little endian format
- using `struct` to pack / unpack data
```python
import struct
struct.pack("B", 1) 
b'\x01'
```
```python
import struct
# pack will output data in little-endian format
struct.pack("H", 1) 
b'\x01\x00' 
```
```python
import struct
struct.pack(">H", 1) # use > to change the output to big endian
b'\x00\x01'
```
```python
import struct
struct.unpack("B", b'\x01')
(1,)

```
- Creating a raw socket using `socket` class `socker.socket(socket.PF_PACKET, socket.SOCK_RAW, socket.htons(0x8000))`
    - `socket.PF_PACKET` use the packet interface
    - `socket.SOCK_RAW` use raw socket
    - `socket.htons(0x0800)` tell the kernel which protocol to use 
        - `0x0800` to specify IP protocol
            - find protocol IDs check `/var/include/linux/if_ether.h`
    - To create raw socket the user has to be either root or has permissions to create raw sockets
       
